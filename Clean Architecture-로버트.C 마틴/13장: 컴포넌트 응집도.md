# 📕 컴포넌트 응집도
어떤 클래스에 어떤 컴포넌트를 포함시킬지는 매우 중요한 결정이다.  
안타깝게도 수년 동안 우리는 대부분 상황에 따라 임시방편으로 이러한 결정을 내려왔다.

컴포넌트 관련 세 가지 원칙
- **REP**: 재사용/릴리스 등가 원칙  
- **CCP**: 공통 폐쇄 원칙  
- **CRP**: 공통 재사용 원칙  

## 📗 REP: 재사용/릴리스 등가 원칙 
> **"재사용 단위는 릴리스 단위와 같아야 한다."**

컴포넌트가 릴리스 절차를 통해 관리되지 않거나 릴리스 번호가 부여되지 않는다면,  
해당 컴포넌트를 재사용하고 싶어도 제대로 사용할 수 없다.  
이 점에서 **REP는 너무나 당연한 원칙**이다.

하지만 이 원칙이 단지 그 이유 때문만은 아니다.  
소프트웨어 개발자들이 새로운 버전의 출시 시점과 변경 사항을 정확히 알아야 하기 때문이다.

아키텍처 관점에서 보면,  
단일 컴포넌트는 응집력 높은 클래스와 모듈들로 구성되어야 한다.  
즉, 컴포넌트를 이루는 모든 모듈은 서로 공유하는 명확한 목적이나 테마가 있어야 한다.

또 다른 관점에서 보면,  
하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 **함께 릴리스할 수 있어야 한다.**

물론 클래스와 모듈을 하나의 컴포넌트로 묶는 구체적인 방법은 설명하기 어렵다.  
그럼에도 불구하고 이 원칙 자체는 충분히 중요하며,  
그 약점은 **CCP**와 **CRP** 원칙이 가진 강점을 통해 보완할 수 있다.

## 📗 CCP: 공통 폐쇄 원칙
> **"동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.  
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라."**

이 원칙은 SRP(단일 책임 원칙)를 컴포넌트 관점에서 다시 쓴 것이다.    
SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 하듯,  
**CCP에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.**

애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.

CCP는 변경될 가능성이 있는 클래스들을 하나의 컴포넌트로 묶을 것을 권장한다.  
물리적으로 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은  
하나의 컴포넌트에 속해야 한다.  
이를 통해 소프트웨어의 릴리스, 재검증, 배포와 관련된 작업량을 최소화할 수 있다.

CCP는 OCP(개방-폐쇄 원칙)와도 밀접하게 연관되어 있다.  
여기서 말하는 ‘폐쇄’는 OCP에서 말하는 그것과 동일한 의미이다.

완전한 폐쇄는 불가능하므로, 전략적으로 폐쇄해야 한다.  
즉, 공통적인 변경에 대해 클래스가 닫혀 있도록 설계해야 한다.

CCP는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써,  
OCP의 교훈을 컴포넌트 수준에서 확대 적용한다.  
그 결과, 변경의 영향이 미치는 컴포넌트의 수를 최소화할 수 있다.

### 📘 SRP와의 유사성
CCP는 컴포넌트 수준에서의 SRP이다.  
두 원칙은 다음과 같은 동일한 교훈으로 요약할 수 있다:

> **동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라.  
> 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.**

## 📗 CRP: 공통 재사용 원칙
> **"컴포넌트 사용자들에게 필요하지 않은 것에 의존하도록 강요하지 말라."**

CRP는 함께 재사용되는 경향이 있는 클래스와 모듈들을 동일한 컴포넌트에 포함시켜야 한다고 말한다.

재사용 가능한 클래스는 일반적으로 해당 모듈의 다른 클래스들과 상호작용하는 경우가 많다.  
CRP는 이러한 클래스들이 동일한 컴포넌트에 포함되어야 한다고 강조한다.

CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 알려줄 뿐 아니라,  
**동일한 컴포넌트로 묶어서는 안 되는 클래스**가 무엇인지도 알려준다.

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 **의존성**이 생긴다.  
사용하는 쪽에서 상대 컴포넌트의 클래스 중 단 하나만 사용하더라도  
해당 컴포넌트 전체에 의존하게 된다.

이러한 의존성으로 인해, 사용되는 컴포넌트에 변화가 생기면  
그 변화가 전혀 관련 없는 내용이라도  
사용하는 컴포넌트에 영향을 미치고, 변경이 필요해질 수 있다.

따라서 한 컴포넌트에 의존한다는 것은 **그 컴포넌트의 모든 클래스에 의존하는 것**임을 인지해야 한다.  
즉, 컴포넌트에 포함된 클래스들을 더 작게 나누어 따로 의존할 수는 없다.  
일부 클래스에만 의존하고 나머지와는 독립적일 수 없다는 뜻이다.

이러한 이유로, CRP는 어떤 클래스를 묶을 수 있는가보다는  
**어떤 클래스를 함께 묶어서는 안 되는가**에 더 많은 초점을 맞춘다.  
CRP는 **강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 포함시켜서는 안 된다**고 말한다.

### 📘 ISP와의 관계
CRP는 ISP(인터페이스 분리 원칙)의 더 포괄적인 버전이다.  
두 원칙은 다음 한 문장으로 요약할 수 있다:

> **필요하지 않은 것에 의존하지 말라.**

## 📗 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 관한 세 가지 원칙은 서로 상충되는 경향이 있다.

**REP**와 **CCP**는 포함 원칙이다.  
즉, 이 두 원칙은 컴포넌트를 **더 크게** 만든다.

반면, **CRP**는 배제 원칙으로,  
컴포넌트를 **더 작게** 만든다.

아래 다이어그램은 이 세 원칙이 서로 어떻게 상호작용하는지를 시각적으로 보여준다.  
각 변은 반대편 꼭짓점에 있는 원칙을 포기했을 때 발생할 수 있는 **비용**을 의미한다.

<img src="../Clean Architecture-로버트.C 마틴/img/13_1.png" alt="설명" width="500" style="display: block; margin: auto;">

예를 들어, **REP**와 **CRP**에만 중점을 둘 경우,  
사소한 변경 하나가 너무 많은 컴포넌트에 영향을 미치게 된다.  

반대로 **CCP**와 **REP**에만 과도하게 집중하면,  
불필요한 릴리스가 지나치게 자주 발생할 수 있다.

일반적으로 프로젝트는 삼각형의 오른쪽, 즉 **재사용성 중심**에서 시작하는 경우가 많으며,  
이 시점에서는 **재사용성만 희생하면** 된다.

하지만 프로젝트가 점차 성숙하고,  
해당 프로젝트를 기반으로 또 다른 프로젝트가 파생되기 시작하면,  
삼각형의 왼쪽으로 이동하게 된다.

즉, 컴포넌트 구조는 **시간과 성숙도에 따라 변화**한다.  
이는 프로젝트가 ‘무엇을 하느냐’보다는  
‘어떻게 발전되고 사용되는가’에 더 밀접한 관련이 있음을 의미한다.

## 📗 결론
과거에는 결합도에 대한 인식 수준이 단순했다.  
응집도를 단지 "모듈은 단 하나의 기능만 수행해야 한다"는 정도로 이해했던 시절도 있었다.  
그러나 컴포넌트 응집도에 관한 세 가지 원칙은,  
응집도가 실제로는 훨씬 더 **복잡하고 다양한 특성**을 가질 수 있음을 보여준다.

어떤 클래스들을 묶어 하나의 컴포넌트로 만들 것인지를 결정할 때는  
**재사용성**과 **개발 가능성**이라는 상충하는 힘을 반드시 고려해야 한다.  
이들 사이에서 애플리케이션의 요구에 맞게 **균형을 잡는 일**이 중요하다.

이 균형점은 거의 항상 **유동적**이다.  
현재 상황에 맞게 재사용성과 개발 가능성 사이의 균형을 잘 맞췄더라도,  
시간이 지나 내년이 되면 그 균형이 더 이상 유효하지 않을 수 있다.

결국, 시간이 흐르며 프로젝트의 초점이 **개발 가능성**에서 **재사용성**으로 옮겨가고,  
그에 따라 컴포넌트의 구성 방식도 점차 **흐트러지며 진화**하게 된다.
