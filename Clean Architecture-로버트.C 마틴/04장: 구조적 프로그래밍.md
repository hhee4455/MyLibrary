# 📕 구조적 프로그래밍
데이크스트라는 진공관 시대에 활동했다. 이 시대는 컴퓨터가 극도로 제한적으로만 사용될 때였다. 프로그램을 바이너리로 또는 매우 투박한 기계어를 이용해서 작성했다.
<br>

**데이크스트라는 이처럼 원시적인 환경에서 위대한 발견을 했다.**

## 📗 증명
데이크스트라는 프로그램이 너무 많은 세부사항을 담고 있어 작은 실수라도 발생하면 결국 예상치 못한 방식으로 실패할 수 있음을 인식했다. 이를 해결하기 위해 그는 증명이라는 수학적 원리를 적용하고자 했으며, **유클리드 계층구조**를 만들려는 비전을 제시했다.  

이 개념에서 프로그래머는 입증된 구조를 사용하고, 이를 코드와 결합하며, 코드의 올바름을 스스로 증명할 수 있는 방식으로 프로그래밍해야 했다. 따라서 단순한 알고리즘에 대한 증명 기법을 먼저 개발하는 것이 필요했다.  

이 과정에서 데이크스트라는 goto 문장이 재귀적으로 분해될 때 문제가 발생한다는 점을 발견했다.  
- 모듈을 효과적으로 분해할 수 없다면 분할 정복 알고리즘을 사용할 수 없으며,  
- 따라서 모듈화된 프로그램 설계가 어려워진다.  

그는 `goto`의 대안으로 if/then/else, do/while 같은 단순한 제어 구조가 적절하다는 사실을 발견했고,  
이러한 구조를 사용하면 프로그램을 재귀적으로 세분화하는 것이 가능해진다는 점을 깨달았다.

이후 순차 실행과 결합된 제어 구조가 특별한 의미를 가진다는 점을 인식했다.  
데이크스트라보다 2년 앞서 뵘과 야코피니가 **모든 프로그램이 순차, 분기, 반복이라는 세 가지 구조만으로 표현될 수 있음**을 증명했으며,  
결국 **이러한 구조가 모든 프로그램을 만드는 최소한의 제어 구조라는 점이 밝혀졌다**.  

이를 통해 구조적 프로그래밍이 탄생했다.

### 📘 증명 방식
- **순차 구문**: 단순한 열거법을 이용한 증명  
- **분기 구문**: 열거법을 확장하여 증명  
- **반복 구문**: 귀납법을 이용하여 증명  

이 증명을 해냄으로써 프로그램에서도 정리에 대한 유클리드 계층구조를 만들 수 있을 거라는 생각이 실제로 이루어질 듯 보였다.

## 📗 기능적 분해
구조적 프로그래밍을 통해 모듈을 기능적으로 분해할 수 있음을 알게 되었다.

즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있다.

시간이 지나면서 이 기법을 개선했고 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있게 되었다.

## 📗 결론
구조적 프로그래밍이 현재까지 가치가 있는 이유는 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다. 또 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. <br>
**소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주하게 노력해야 된다.**