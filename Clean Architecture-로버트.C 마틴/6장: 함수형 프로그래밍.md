# 📕 함수형 프로그래밍
**"함수형 프로그래밍 패러다임에서 핵심이 되는 기반은 람다 계산법이다."**

## 📗 클로저와 함수형 프로그래밍
클로저는 끝이 없는 리스트의 어떤 항목도 실제로 접근하기 전에는 평가가 이뤄지지 않는다.  
자바 프로그램은 가변 변수를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.

**"함수형 언어에서 변수는 변경되지 않는다."**

## 📗 불변성과 아키텍처
아키텍트가 변수의 가변성을 염려하는 이유는 크게 세 가지가 있다.  
가변 변수로 인해 **경합 조건(Race Condition), 교착 상태(Deadlock), 동시 업데이트 문제**가 발생한다.  

동시성 애플리케이션(스레드와 프로세스)에서 발생하는 모든 문제는 가변 변수가 없다면 절대 생기지 않는다.

따라서 아키텍트는 동시성 문제에 지대한 관심이 필요하며,  
동시성 애플리케이션을 개발할 때 불변성이 가능한지를 반드시 고려해야 한다.

그러나 **불변성을 유지하는 것이 이상적일지라도, 현실적으로는 타협이 필요할 수 있다.** 


## 📗 가변성의 분리
불변성과의 가장 중요한 타협점은 **애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 것**이다.  

- 불변 컴포넌트는 순수 함수형 방식으로 동작하며, 가변 변수를 사용하지 않는다.  
- 불변 컴포넌트는 변수 상태를 변경할 수 있는 다른 컴포넌트와 통신한다.  

<img src="../Clean Architecture-로버트.C 마틴/img/6_1.png" alt="설명" width="400" style="display: block; margin: auto;">

상태 변경이 발생하면 컴포넌트가 다양한 동시성 문제에 노출될 위험이 있다.  
이를 방지하기 위해 트랜잭션 메모리 같은 기법을 활용하여 가변 변수를 보호해야 한다.  

- 트랜잭션을 사용하거나  
- 재시도(retry) 기법을 활용하여 동시 업데이트 및 경합 조건 문제를 방지할 수 있다.  

애플리케이션을 올바르게 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.  

**"현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮기고,  
가변 컴포넌트에서는 최대한 많은 코드를 제거해야 한다."**  

## 📗 이벤트 소싱
메모리가 증가하고 기계의 성능이 향상될수록, 필요한 가변 상태는 점점 줄어든다.  

예를 들어, 은행 애플리케이션에서 입출금 트랜잭션이 실행되면 계좌 잔고가 변경된다.  
하지만 잔고를 직접 변경하는 대신, 트랜잭션 자체를 저장한다면  
가변 변수를 사용하지 않고도 동일한 기능을 구현할 수 있다.  

그러나 시간이 지나면서 트랜잭션 수는 계속 증가하며,  
결국에는 무한한 저장 공간과 처리 능력이 필요해진다.  

하지만 애플리케이션의 전체 수명 주기 동안만 정상적으로 동작할 정도의 저장 공간과 처리 능력이 있다면,  
이 전략은 현실적으로 충분히 적용할 수 있다.  

이벤트 소싱은 **상태를 저장하는 대신 트랜잭션을 저장하는 방식**이다.  
필요할 때 **초기 상태부터 모든 트랜잭션을 다시 처리**하여 최신 상태를 계산한다.  

이 방식에서는 데이터 저장소에서 삭제되거나 변경되는 데이터가 전혀 없다.  
즉, 애플리케이션은 CRUD가 아닌 CR(Create, Read)만 수행한다.  

이러한 특성 덕분에, 데이터 저장소에서 동시 업데이트 문제가 발생하지 않는다.  
충분한 저장 공간과 처리 능력이 있다면,  
애플리케이션을 **완전한 불변성 기반으로 설계할 수 있으며, 결과적으로 순수 함수형 시스템으로 만들 수 있다.**  

## 📗 결론
- **구조적 프로그래밍**은 **제어 흐름의 직접적인 전환**에 대한 규율이다.  
- **객체 지향 프로그래밍**은 **제어 흐름의 간접적인 전환**에 대한 규율이다.  
- **함수형 프로그래밍**은 **변수 할당**에 대한 규율이다.  

이들 세 가지 패러다임은 **각각 무언가를 제한하며, 코드 작성 방식을 한정**시킨다.  
어떤 패러다임도 **우리의 능력을 확장하는 것이 아니라, 제약을 가하는 방식으로 작동한다.**  

우리가 배운 것은 **무엇을 해야 하는가가 아니라, 무엇을 해서는 안 되는가**이다.  

소프트웨어는 급격히 변화하는 기술이 아니라는 **냉정한 진실**과 마주하게 된다.  
도구가 바뀌고 하드웨어가 발전했지만, **소프트웨어의 본질은 변하지 않았다.**  

소프트웨어, 즉 컴퓨터 프로그램은 **순차(Sequence), 분기(Selection), 반복(Iteration), 참조(Reference)**로 이루어진다.  
그 이상도, 그 이하도 아니다.  
