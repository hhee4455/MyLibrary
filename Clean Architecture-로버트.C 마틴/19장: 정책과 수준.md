# 📕 정책과 수준
소프트웨어 시스템이란 **정책을 기술한 것**이다.

소프트웨어 아키텍처를 개발하는 기술에는 이러한 **정책을 신중하게 분리**하고,  
**정책이 변경되는 양상에 따라 재편성**하는 일도 포함된다.

좋은 아키텍처라면 각 컴포넌트를 연결할 때 **의존성의 방향이 컴포넌트의 수준**을 기반으로 연결되도록 해야 한다.  
즉, **저수준 컴포넌트가 고수준 컴포넌트에 의존**하도록 설계되어야 한다.

## 📗 수준
‘**수준**’을 정의하면 **입력과 출력까지의 거리**라고 할 수 있다.

- **입출력의 거리가 멀어질수록** 정책의 수준은 **높아진다**.
- 반대로, **입력과 출력을 직접 다루는 정책**은 시스템의 **최하위 수준**에 위치한다.

<img src="../Clean Architecture-로버트.C 마틴/img/19_1.png" alt="설명" width="500" style="display: block; margin: auto;">

번역 컴포넌트는 이 시스템에서 **가장 높은 수준의 컴포넌트**인데,  
그 이유는 **입력과 출력에서 가장 멀리 떨어져 있기 때문**이다.

주목할 점은, **데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다**는 사실이다.

- **소스 코드 의존성은 수준에 따라 결합**되어야 하며,  
- **데이터 흐름을 기준으로 결합**되어서는 안 된다.

아래의 클래스 다이어그램은 아키텍처를 개선한 모습이다.  
**점선은 경계**를 나타내며,  
**모든 의존성은 경계의 안쪽으로 향한다**.  

이 경계로 묶인 영역이 이 시스템에서 **최고 수준의 구성 요소**이다.

<img src="../Clean Architecture-로버트.C 마틴/img/19_2.png" alt="설명" width="500" style="display: block; margin: auto;">

이 구조는 **고수준의 암호화 정책을 저수준으로부터 분리한 구조**이다.

정책을 컴포넌트로 묶는 기준은 **정책이 변경되는 방식**에 달려 있다는 사실을 상기하자.

- **단일 책임 원칙**과 **공통 폐쇄 원칙**에 따르면, 동일한 이유로 동일한 시점에 변경되는 정책은 **함께 묶어야 한다**.

- **고수준 정책은 변경이 적고, 중요한 이유로 바뀐다.**

모든 소스 코드 의존성이 **고수준 정책을 향하도록 분리**했다면,  
그로 인해 **변경의 영향도는 최소화될 수 있다**.
