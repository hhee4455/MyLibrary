## 📗 SDP: 안정된 의존성 원칙  
> **"안정성의 방향으로(더 안정된 쪽에) 의존하라."**

**설계는 결코 정적일 수 없다.**  
소프트웨어는 시간이 흐르며 점진적으로 **변화하고 확장되기 때문**이다.

따라서 **변경이 어려운(안정된) 컴포넌트가,  
변동이 예상되는(불안정한) 컴포넌트에 의존해서는 안 된다.**

일단 안정된 컴포넌트가 불안정한 컴포넌트에 의존하게 되면,  
그 불안정한 컴포넌트도 결국 **변경이 어려운 구조**가 되어버린다.  
이는 시스템 전체의 유연성과 유지보수성을 떨어뜨리는 원인이 된다.

**안정된 의존성 원칙(SDP)** 을 따름으로써,  
**변경하기 어려운 컴포넌트가 변경이 쉬운 컴포넌트에 의존하는 문제**를 방지할 수 있다

### 📘 안정성
소프트웨어에서의 **안정성**은 변경을 가하기 위해 필요한 **작업량**과 밀접한 관련이 있다.

소프트웨어 컴포넌트를 **변경하기 어렵게 만드는 요인**은 여러 가지가 있다.  
예를 들어 컴포넌트의 **크기, 복잡도, 간결함 등**이 있다.

또한 컴포넌트에 **다른 컴포넌트들이 많이 의존**하고 있다면,  
그 컴포넌트는 **상당히 안정적**이라고 볼 수 있다.  
왜냐하면, 사소한 변경이라도 해당 컴포넌트를 사용하는 **모든 의존 컴포넌트에 영향을 미칠 수 있으므로**,  
그만큼 변경에 드는 **비용과 노력**이 크기 때문이다.

<img src="../Clean Architecture-로버트.C 마틴/img/14_5.png" alt="설명" width="400" style="display: block; margin: auto;">

위 다이어그램에서 `X`는 **안정된 컴포넌트**이다.  

<img src="../Clean Architecture-로버트.C 마틴/img/14_6.png" alt="설명" width="400" style="display: block; margin: auto;">

반면, `Y`는 **불안정한 컴포넌트**이다.  

### 📘 안정성 지표
컴포넌트의 **안정성**은 해당 컴포넌트에 **들어오고 나가는 의존성의 수를 기준으로 측정**할 수 있다.  
이 지표를 통해 해당 컴포넌트가 전체 구조 내에서 **얼마나 안정적인 위치에 있는지**를 계산할 수 있다.

- **Fan-in**: 해당 컴포넌트를 **의존하는 외부 컴포넌트 수** (들어오는 의존성)
- **Fan-out**: 해당 컴포넌트가 **의존하는 다른 컴포넌트 수** (나가는 의존성)
- **불안정성 (I)**:  
  - `I = Fan-out / (Fan-in + Fan-out)`
  - `I = 0`이면 **가장 안정된 컴포넌트**를 의미한다.  
  - `I = 1`이면 **가장 불안정한 컴포넌트**를 의미한다.

즉, **Fan-in이 많고 Fan-out이 적을수록**,  
해당 컴포넌트는 **더 안정적**이라고 볼 수 있다.

### 📘 모든 컴포넌트가 안정적이어야 하는 것은 아니다
컴포넌트 구조를 설계할 때 우리가 기대하는 것은  
**안정된 컴포넌트와 불안정한 컴포넌트가 공존하는 상태**이다.

모든 컴포넌트가 지나치게 안정적이면,  
**변경이 매우 어렵고 유연성이 떨어지는 시스템**이 된다.  
따라서 일부 컴포넌트는 **의도적으로 불안정하게 설계**되어야 한다.

#### 추상 컴포넌트
**추상 컴포넌트**는 보통 상당히 안정적인 구조를 갖는다.  
따라서 **덜 안정적인 컴포넌트들이 의존하기에 이상적인 대상**이다.

하지만 **동적 타입 언어**에는 이러한 추상 컴포넌트 개념이 존재하지 않는다.  
그 결과, 해당 언어의 **의존성 구조는 더 단순**해지는 경향이 있다.

## 📗 SAP: 안정된 추상화 원칙
> **"컴포넌트는 안정된 정도만큼만 추상화되어야 한다."**

### 📘 고수준 정책을 어디에 위치시켜야 하는가?
고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 자주 변경되서는 안된다.  
고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 한다.

하지만 고수준 정책을 안정된 컴포넌트에 위치하면,  
소스 코드는 수정하기 어려워진다.  
시스템 전체  아키텍처가 유연성을 잃는다.

이 문제의 해답은 OCP이다.  
OCP를 준수하는 클래스는 추상클래스이다.

### 📘 안정된 추상화 원칙
SAP는 **안정된 컴포넌트는 추상적이어야 한다**고 말한다.  
이는 **안정성이 컴포넌트의 확장을 방해해서는 안 된다**는 의미를 내포한다.

따라서 안정적인 컴포넌트라면 반드시  
**인터페이스**와 **추상 클래스**로 구성되어  
**확장 가능성**을 확보해야 한다.

SAP와 SDP를 결합하면,  
결국 **컴포넌트 수준에서의 DIP**와 유사한 형태가 된다.

- **SDP**는: 의존성이 **더 안정된 방향**으로 향해야 한다고 말한다.  
- **SAP**는: 안정된 컴포넌트는 **추상적**이어야 한다고 말한다.  

결과적으로 **의존성은 추상화의 방향으로 향해야 한다**는 결론이 도출된다.

단, DIP는 **클래스에 대한 원칙**이며,  
클래스는 **추상적이거나 구체적이거나** 둘 중 하나다.

반면, SDP와 SAP는 **컴포넌트에 대한 원칙**이며,  
하나의 컴포넌트는 **일부는 추상적이고, 일부는 안정적일 수 있다.**

### 📘 추상화 정도 측정하기
A 지표는 컴포넌트의 추상화 정도를 측정한 값이다.

- Nc: 컴포넌트의 클래스 개수
- Na: 컴포넌트의 추상 클래스와 인터페이스 개수
- A: 추상화 정도. A = Na / Nc

### 📘 주계열

<img src="../Clean Architecture-로버트.C 마틴/img/14_7.png" alt="설명" width="500" style="display: block; margin: auto;">

A/I 그래프 상에서 컴포넌트가 절대로 위치해서는 안되는 영역 배재할 구역을 찾는 방식으로 추론할 수 있다.

 #### 고통의 구역
(0,0) 근처는 매우 **안정적이고 구체적인** 영역이다.  
이 구역에 위치한 컴포넌트는 **추상적이지 않기 때문에 확장하기 어렵고**,  
**변경에도 큰 부담이 따른다**.  

따라서 **올바르게 설계된 컴포넌트**라면  
이 영역에 **머무르지 않아야 한다.**

하지만 현실적으로  
**데이터베이스 스키마**나 **유틸리티 라이브러리**처럼  
일부 소프트웨어 엔티티는 이 구역에 위치하게 되는 경우도 있다.

#### 쓸모없는 구역
(1,1) 근처는 매우 **불안정하면서도 추상적인** 영역이다.  
이 구역은 기능도 없고, 의존성도 없기 때문에  
**쓸모없는 구역**이라 불린다.

이곳에 존재하는 엔티티는  
**실질적으로 아무런 역할도 하지 못하는 폐기물**과 같다.

### 📘 배제 구역 벗어나기
따라서 **변동성이 큰 컴포넌트**는  
두 배제 구역(고통의 구역과 쓸모없는 구역)으로부터 **멀리 떨어져 있어야 한다**.

(1,0)과 (0,1)을 잇는 선분을 **주계열(Main Sequence)**이라 부른다.  
이 선 위는 **컴포넌트가 위치하기에 가장 바람직한 지점**이다.

하지만 **대규모 시스템**에서는  
일부 컴포넌트가 완벽히 추상적이거나 완전히 안정적인 구조를 갖기 어렵다.  
이러한 경우, 컴포넌트는 **주계열 바로 위 또는 그 근처에 위치할 때** 가장 이상적이다.

### 📘 주계열과의 거리
컴포넌트가 **주계열에 가까울수록** 설계가 잘되었음을 의미한다.  
따라서 컴포넌트가 **주계열로부터 얼마나 떨어져 있는지**를 지표로 표현할 수 있다.

### 📘 결론
의존성 관리 지표는 설계의 **의존성 구조**와 **추상화 정도**가  
우리가 생각하는 '이상적인 패턴'에 **얼마나 잘 부합하는지**를 측정한다.

하지만 이 지표는 결국 **임의로 정해진 기준을 기반으로 한 수치**에 불과하다.  
따라서 아무리 정교하게 만들어도 **불완전할 수밖에 없다.**

중요한 것은, 이러한 지표를 통해 **실제로 유용한 통찰을 얻어내기 위해 노력하는 것**이다.
