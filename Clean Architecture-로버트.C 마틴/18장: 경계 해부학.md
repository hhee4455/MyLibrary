# 📕 경계 해부학
경계는 다양한 형태로 나타난다.

## 📗 경계 횡단하기
적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

왜냐하면, 소스 코드 모듈 하나가 변경되면,  
이에 의존하는 다른 소스 코드 모듈이 변경하기 때문이다.  
경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.

## 📗 두려운 단일체
아키텍처 경계 중에서 단순하고 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태이다.  

배포 관점에서 보면 이는 소위 단일체라고 불리는 단일 실행 파일에 지나지 않는다.  

배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다.  
최종적으로 정적으로 링크된 단일 파일을 만들더라도,  
그 안에 포함된 컴포넌트를 개발하고, 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 해야 한다.

가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.  

밑 그림에서는 제어 흐름은 왼쪽에서 오른쪽으로 경계를 횡단한다.

<img src="../Clean Architecture-로버트.C 마틴/img/18_1.png" alt="설명" width="400" style="display: block; margin: auto;">

고수준 클라이언트가 저수준 서비스를 호출해야 한다면 **동적 다형성**을 사용하여 제어 흐름과는 반대 방향으로 의존성을 역진시킬 수 있다.  
이렇게 하면 **런타임 의존성**은 **컴파일타임 의존성**과는 반대가 된다.

밑에 그림에서 제어 흐름은 이전과 마찬가지로 왼쪽에서 오른쪽으로 경계를 횡단한다.  

<img src="../Clean Architecture-로버트.C 마틴/img/18_2.png" alt="설명" width="400" style="display: block; margin: auto;">

단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므로,  
대체로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

## 📗 배포형 컴포넌트
아키텍처 경계가 **물리적으로 드러난 형태**는 **동적 링크 라이브러리**이다.  
(예: `.jar` 파일)

이는 **배포 과정에서만 차이가 날 뿐**, 기본적인 구조와 동작은 **단일체와 동일하다**.

## 📗 스레드
단일체와 배포형 컴포넌트는 모두 **스레드**를 활용할 수 있다.  

그러나 스레드는 **아키텍처 경계도 아니며**, **배포 단위도 아니다**.

## 📗 로컬 프로세스
훨씬 강한 물리적 형태를 띠는 아키텍처 경계로는 **로컬 프로세스**가 있다.  

대개의 경우 로컬 프로세스는 **소켓, 메일박스, 메시지 큐**와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.

로컬 프로세스는 컴포넌트 간 의존성을 **동적 다형성**을 통해 관리하는 **저수준 컴포넌트**로 구성된다.

## 📗 서비스
물리적인 형태를 띠는 **가장 강력한 아키텍처 경계**는 바로 **서비스**이다.

저수준 서비스는 반드시 **고수준 서비스에 '플러그인'** 되어야 한다.  

그리고 **고수준 서비스의 소스 코드에는** 저수준 서비스를 특정 짓는 **어떠한 물리적인 정보도 포함되어서는 안 된다**.
