# 📕 객체 지향 프로그래밍
좋은 아키텍처는 객체 지향(OO,Object-Oriented) 설계 원칙을 이해하고 응용하는 데서 출발한다.

**"객체 지향의 본질은 캡슐화, 상속, 다형성이다."**

## 📗 캡슐화
캡슐화는 객체 지향 언어에만 국한된 개념이 아니다.<br>
**C 언어에서도 완벽한 캡슐화가 가능했었다.**  

하지만 C++이 등장하면서, 기술적인 이유로 C가 제공하던 완전한 캡슐화가 C++에서 깨지게 되었다.<br>
이를 보완하기 위해 `public`, `private`, `protected` 키워드가 도입되었지만,  
이는 어디까지나 임시방편적인 해결책이었다.  

특히 자바(Java)와 C#은 헤더와 구현체를 분리하는 방식을 없앴고,  
이로 인해 캡슐화가 심각하게 훼손되었다.  
이러한 언어에서는 클래스의 선언과 정의를 분리하는 것이 불가능하다.

결과적으로, 객체 지향이 강력한 캡슐화에 의존한다는 주장은 받아들이기 어렵다.<br> 
오히려, 객체 지향 언어들은 기존 C 언어에서 가능했던 완벽한 캡슐화를 약화시켜 왔다.

## 📗 상속
상속은 단순히 **변수와 함수를 하나의 유효 범위로 묶어 재정의하는 과정**에 불과하다.  
객체 지향 언어가 등장하기 이전에도 C 언어에서 상속과 유사한 기법이 사용되었다.  

하지만 C 언어에서는 상속을 흉내 내는 방법은 있었지만, 객체 지향 언어만큼 편리하지는 않았다.<br>
즉, 객체 지향 언어가 완전히 새로운 개념을 만든 것은 아니지만, **보다 편리한 방식으로 상속을 제공했다**고 볼 수 있다.

## 📗 다형성
다형성이란 **함수를 가리키는 포인터를 이용하는 것**을 의미한다.  
프로그래머들은 오래전부터 함수 포인터를 활용하여 다형적 행위를 수행해 왔으며,  
따라서 객체 지향이 다형성을 새롭게 만든 것은 아니다.  

객체 지향 언어는 다형성을 직접 제공하지는 않지만, 보다 안전하고 편리하게 사용할 수 있도록 개선했다.  

다형성을 직접 구현하는 문제점은 함수 포인터를 직접 사용하여 다형적 행위를 만드는 방식은 위험성을 내포하고 있다.  
- 프로그래머는 포인터를 초기화하는 관례를 반드시 준수해야 한다.  
- 포인터를 통해 함수를 호출하는 규칙도 철저히 따라야 한다.  

만약 이러한 관례를 망각하면 버그가 발생할 가능성이 높아진다.  

객체 지향 언어는 이러한 복잡한 관례를 없애줌으로써 실수를 방지한다.  
즉, 객체 지향 언어를 사용하면 다형성은 자연스럽고 직관적으로 활용할 수 있는 개념이 된다.  

**"객체 지향은 제어 흐름을 간접적으로 전환하는 규칙을 부과한다."**

### 📘 의존성 역전
객체 지향이 등장하기 전에는 `main` 함수가 고수준 함수를 호출하고,  
고수준 함수는 중간 수준 함수를, 중간 수준 함수는 저수준 함수를 호출했다.  
이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어 흐름을 따라가게 된다.

<img src="../Clean Architecture-로버트.C 마틴/img/5_1.png" alt="설명" width="500" style="display: block; margin: auto;">

제어 흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 이 제어 흐름을 따르게 된다.

하지만 다형성이 도입되면 다음과 같은 구조가 된다.

<img src="../Clean Architecture-로버트.C 마틴/img/5_2.png" alt="설명" width="200" style="display: block; margin: auto;">

ML1과 I 인터페이스 사이의 소스 코드 의존성이 제어 흐름과 반대 방향이 된다.  
이를 **의존성 역전** 이라고 한다.  

객체 지향 언어는 다형성을 안전하고 편리하게 제공하기 때문에,  
**소스 코드 의존성을 어디에서든 역전시킬 수 있다.**  

객체 지향 언어를 사용하는 소프트웨어 아키텍트는 시스템 내 모든 소스 코드 의존성의 방향을 결정할 수 있는 절대적인 권한을 가진다.  
즉, 소스 코드 의존성이 제어 흐름의 방향과 반드시 일치해야 한다는 제한이 사라진다.

**"이것이 바로 객체 지향이 제공하는 힘이다."**  

이러한 개념을 적용하면, 업무 규칙이 데이터베이스와 사용자 인터페이스(UI)에 의존하는 것이 아니라,  
오히려 데이터베이스와 UI가 업무 규칙에 의존하도록 시스템을 설계할 수 있다.

<img src="../Clean Architecture-로버트.C 마틴/img/5_3.png" alt="설명" width="500" style="display: block; margin: auto;">

업무 규칙을 포함하는 소스 코드에서는 UI나 데이터베이스를 직접 호출하지 않는다.  
결과적으로, 업무 규칙을 포함하는 컴포넌트는 UI와 데이터베이스를 포함하는 컴포넌트에 의존하지 않는다.  

따라서 업무 규칙을 UI와 데이터베이스와 독립적으로 배포할 수 있다.  
이러한 컴포넌트는 개별적으로 관리되며, 특정 컴포넌트의 코드가 변경되면  
**해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.**  

**"이것이 바로 배포 독립성이다."**  

또한, 시스템의 모듈이 독립적으로 배포 가능해지면,  
**서로 다른 팀이 각 모듈을 독립적으로 개발할 수 있다.**  

**"이것이 바로 개발 독립성이다."**  

## 📗 결론
객체 지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 흭득할 수 있는 능력이다.

객체 지향을 사용하면 고수준의 정책을 포함하는 모듈을 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.

저수준의 모듈과 고수준의 모듈을 독립적으로 개발하고 배포할 수 있다.
