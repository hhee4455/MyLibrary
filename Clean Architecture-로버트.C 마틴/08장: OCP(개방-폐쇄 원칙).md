# 📕 OCP 개방-폐쇄 원칙

OCP(Open-Closed Principle)는 다음과 같이 정의된다.  

> **"소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."**  

즉, **소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 기존 코드를 변경해서는 안 된다.**  

소프트웨어 아키텍처를 공부하는 근본적인 이유 또한 OCP 원칙을 실현하는 데 있다.  

많은 초보 개발자들은 OCP를 클래스와 모듈 설계를 위한 원칙으로 이해한다.  
그러나 **아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 더 중요한 의미를 가진다.**  

이를 명확히 이해하기 위해, **사고 실험(Thought Experiment)을 통해 접근해볼 수 있다.**  

## 📗 사고실험
재무제표를 웹 페이지에 표시하는 시스템을 예로 들어보자.  
새로운 기능을 추가하거나 수정해야 할 때, 기존 코드를 얼마나 변경해야 할까?  
훌륭한 소프트웨어 아키텍처라면 **변경되는 코드의 양을 최소화하며, 이상적인 변경량은 0이다.**  

이를 실현하기 위해 **단일 책임 원칙(SRP)** 과 **의존성 역전 원칙(DIP)** 을 적용할 수 있다.  

SRP를 적용하면 보고서 생성이 서로 다른 두 개의 책임으로 분리된다.  
이렇게 하면 각 기능을 수정하거나 추가할 때 다른 기능에 영향을 주지 않도록 보호할 수 있다.  

<img src="../Clean Architecture-로버트.C 마틴/img/8_1.png" alt="설명" width="400" style="display: block; margin: auto;">
<br>

이러한 목적을 달성하려면, 처리 과정을 클래스 단위로 분할하고,  
이를 이중선으로 표시된 컴포넌트 단위로 구분해야 한다.  

<img src="../Clean Architecture-로버트.C 마틴/img/8_2.png" alt="설명" width="500" style="display: block; margin: auto;">
<br>

모든 의존성은 소스 코드 의존성을 나타내며, 단방향으로 이루어진다.  
즉, 저수준 컴포넌트는 고수준 컴포넌트에 영향을 미치지 않아야 한다.  

<img src="../Clean Architecture-로버트.C 마틴/img/8_3.png" alt="설명" width="400" style="display: block; margin: auto;">
<br>

예를 들어,  
- `Presenter`의 변경이 `Controller`에 영향을 주지 않도록 보호해야 한다.  
- `View`의 변경이 `Presenter`에 영향을 주지 않도록 보호해야 한다.  
- **Interactor는 다른 모든 변경으로부터 보호받아야 한다.**  

Interactor는 업무 규칙을 포함하는 가장 중요한 컴포넌트이며,  
Database, Controller, Presenter, View의 변경으로부터 최고 수준의 보호를 받는다.  

이러한 보호 계층 구조는 **"수준(Level)"** 을 기반으로 형성된다.  
- **Interactor는 가장 높은 수준**의 개념이며, 최고의 보호를 받는다.  
- **View는 가장 낮은 수준**의 개념이며, 보호를 거의 받지 못한다.  

이것이 **아키텍처 수준에서 OCP가 동작하는 방식**이다.  
아키텍트는 **기능을 분리하고, 이를 컴포넌트 계층 구조로 조직화하여,  
저수준 컴포넌트의 변경이 고수준 컴포넌트에 영향을 주지 않도록 보호해야 한다.**  

## 📗 결론
OCP는 **시스템 아키텍처를 떠받치는 핵심 원동력 중 하나**이다.  

OCP의 목표는 **시스템을 확장하기 쉽게 만들면서도, 변경이 시스템 전체에 과도한 영향을 미치지 않도록 하는 것**이다.  

이를 달성하려면 **시스템을 컴포넌트 단위로 분리**하고,  
**저수준 컴포넌트의 변경이 고수준 컴포넌트에 영향을 주지 않도록 보호하는 의존성 계층 구조**를 만들어야 한다.  