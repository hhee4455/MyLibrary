# 📕 프레젠터와 험블 객체
프레젠터는 **험블 객체 패턴**을 따르는 구조로, 아키텍처의 경계를 식별하고 보호하는 데 도움을 준다.  
실제로 앞선 "클린 아키텍처" 장에서도 험블 객체의 구현 예시들을 다수 확인할 수 있었다.

## 📗 험블 객체 패턴
험블 객체 패턴은 테스트가 어려운 로직과 테스트가 쉬운 로직을 분리하여, 단위 테스트를 쉽게 만들기 위한 디자인 패턴이다.  
핵심 아이디어는 테스트가 어려운 모든 동작을 별도의 객체(험블 객체)로 분리하고, 나머지 테스트 가능한 로직은 별도의 모듈로 옮기는 것이다.

예를 들어 GUI의 경우, 각 요소가 정확한 위치에 있는지를 테스트하는 것은 어렵지만, 대부분의 동작 로직은 테스트하기 쉽다.  
험블 객체 패턴을 사용하면 이 둘을 분리하여 **뷰**와 **프레젠터**라는 두 클래스로 나눌 수 있다.

## 📗 프레젠터와 뷰
- **뷰**: 테스트가 어려운 험블 객체
- **프레젠터**: 테스트가 쉬운 핵심 객체

화면에 보이는 모든 버튼은 고유한 이름을 갖는다. 이 이름은 문자열로서 뷰 모델 내에 존재하며, 프레젠터가 이를 설정한다.  
버튼을 비활성화해야 할 경우에도 프레젠터는 뷰 모델 내의 불리언 플래그를 조작한다.

메뉴 항목, 라디오 버튼, 체크박스, 텍스트 필드 등 모든 UI 요소 역시 문자열 또는 불리언 값으로 뷰 모델에 정의되며, 프레젠터가 이를 관리한다.  
테이블 형태의 수치 데이터를 보여줘야 할 경우에도 프레젠터는 적절한 형식의 문자열 리스트를 뷰 모델에 설정한다.

요약하자면, **화면에 표시되며 애플리케이션이 어느 정도 제어할 수 있는 요소는 모두 뷰 모델 내부에 문자열, 불리언, 열거형 등의 데이터로 존재**해야 한다.  
뷰는 이러한 데이터를 화면에 표현만 할 뿐이며, 그 외의 역할은 없다. 따라서 뷰는 매우 단순하고, 존재감이 거의 없다.

## 📗 테스트와 아키텍처
**테스트 용이성**은 오래전부터 좋은 아키텍처가 갖춰야 할 중요한 속성으로 여겨져 왔다.  
험블 객체 패턴은 그 대표적인 예로, 테스트 가능한 로직과 테스트하기 어려운 로직을 분리함으로써 자연스럽게 아키텍처의 경계를 정의할 수 있게 해준다.

## 📗 데이터베이스 게이트웨이
**유스케이스 인터랙터**와 데이터베이스 사이에는 **데이터베이스 게이트웨이**가 존재한다.  
게이트웨이는 다형적인 인터페이스로서, 애플리케이션이 데이터베이스에 대해 수행할 CRUD 작업 전반을 정의한다.

유스케이스 계층은 SQL을 직접 다루지 않는다.  
대신 필요한 동작을 추상화한 게이트웨이 인터페이스를 호출하고, 그 실제 구현체는 데이터베이스 계층에 존재한다.  
이 구현체가 바로 **험블 객체**다.

이 구현체는 SQL을 직접 실행하거나, 데이터베이스와 상호작용할 수 있는 다양한 인터페이스를 사용할 수 있다.  
반면, 인터랙터는 비즈니스 규칙을 캡슐화하며 **험블 객체가 아니기 때문에 테스트가 용이하다**.  
테스트 시 게이트웨이는 **스텁** 또는 **테스트 더블**로 쉽게 대체 가능하다.

## 📗 데이터 매퍼
객체 관계 매퍼(ORM)는 이름만큼 정확하지 않다.  
객체는 단순한 데이터 구조가 아니며, 사용하는 입장에서 **데이터가 아닌 행위의 집합**으로 여겨진다.  
객체의 데이터는 대부분 `private`으로 선언되므로 외부에서는 접근이 제한된다.

반면, **데이터 구조**는 `public` 필드로 구성된 값들의 묶음이며, 행위를 내포하지 않는다.  
이러한 이유로 ORM보다는 **데이터 매퍼**라는 용어가 더 적절하다.  
데이터 매퍼는 관계형 데이터베이스에서 가져온 값을 특정한 데이터 구조로 변환하는 역할을 한다.

ORM 시스템은 **데이터베이스 계층**에 위치해야 한다. 
ORM은 게이트웨이 인터페이스와 실제 데이터베이스 사이에서 동작하며, 또 하나의 **험블 객체 경계**를 형성하는 역할을 한다.

## 📗 서비스 리스너
서비스가 외부의 다른 서비스와 반드시 통신해야 한다면, 이때도 **험블 객체 패턴**을 통해 서비스 간 경계를 명확히 구분할 수 있다.

일반적으로 애플리케이션은 외부에 전달할 데이터를 **단순한 데이터 구조** 형태로 준비한 뒤,  
이 구조를 서비스 경계를 넘어 특정 모듈에 전달한다.  
해당 모듈은 데이터를 외부 서비스가 요구하는 포맷으로 변환해 전송한다.

반대로 외부 서비스로부터 데이터를 수신할 경우,  
**서비스 리스너**가 외부 서비스 인터페이스로부터 데이터를 받아들인 뒤,  
이를 애플리케이션에서 사용할 수 있도록 **간단한 데이터 구조**로 변환한다.  
변환된 데이터는 다시 서비스 경계를 넘어 내부 로직으로 전달된다.