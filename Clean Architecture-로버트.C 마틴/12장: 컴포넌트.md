# 📕 컴포넌트  
컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위이다.  
예를 들어, 자바의 경우 jar 파일이 컴포넌트에 해당한다.  

컴포넌트는 여러 방식으로 배포될 수 있다.  
- 여러 개의 컴포넌트를 링크하여 단일 파일로 생성  
- .jar, .dll 같은 동적으로 로드할 수 있는 플러그인 형태  
- .exe 파일로 만들어 독립적으로 배포  

잘 설계된 컴포넌트는 **독립적으로 배포가 가능해야 하며,  
이는 독립적인 개발이 가능해야 한다는 의미**이기도 하다.  

## 📗 컴포넌트의 간략한 역사  
초창기 소프트웨어 개발에서는 개발자가 메모리에서 프로그램의 위치와 레이아웃을 직접 제어해야 했다.  
이는 개발자가 가장 먼저 결정해야 하는 중요한 사항 중 하나였다.  

당시에는 라이브러리 함수를 사용하려면 개발자가 라이브러리 소스 코드를 애플리케이션 코드에 직접 포함시켜 하나의 단일 프로그램으로 컴파일해야 했다.  

그러나 자원이 한정적이었기 때문에, 이러한 접근법은 여러 문제를 초래했다.  

컴파일 시간을 단축하고 효율성을 높이기 위해  
개발자는 함수 라이브러리를 애플리케이션 코드로부터 분리하기 시작했다.  

하지만 프로그램과 라이브러리가 사용하는 **메모리가 증가하면서,  
메모리 공간이 부족해지는 문제가 발생**했고,  
이를 해결하기 위한 새로운 접근법이 필요하게 되었다.  

## 📗 재배치성  
이 문제를 해결하기 위해 **재배치가 가능한 바이너리**가 도입되었다.  
이는 **지능적인 로더**를 사용하여 메모리에 재배치할 수 있도록  
컴파일러를 수정하는 방식이었다.  

또한, **컴파일러는 재배치 가능한 바이너리 내부의 함수 이름을  
메타데이터 형태로 생성**하도록 변경되었다.  

- 프로그램이 **라이브러리 함수를 호출**하면,  
  함수 이름을 **외부 참조** 로 생성  
- 라이브러리 함수가 **정의된 프로그램**에서는,  
  해당 이름을 **외부 정의** 로 생성  

이 방식을 통해 **외부 정의가 로드될 위치가 정해지면,  
로더가 외부 참조를 외부 정의에 링크할 수 있게** 되었다.  

이 과정에서 **링킹 로더** 가 탄생했다.  

## 📗 링커  
**링킹 로더**의 등장으로,  
프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있었다.  
그러나 프로그램이 점점 커지면서 링킹 로더의 속도가 느려지는 문제가 발생했다.  

결국, 링크 과정과 로드 과정이 두 단계로 분리되었다.  
- 프로그래머가 링크 과정을 별도로 수행하게 되었고,  
- 이를 처리하는 **링커**라는 애플리케이션이 등장했다.  

**링커는 링크가 완료된 재배치 코드를 생성**하여,  
로더가 더 빠르게 프로그램을 실행할 수 있도록 만들었다.  

그러나 프로그램이 계속 커지면서 컴파일-링크 시간이 병목이 되었다.  
- 소스 코드(`.c` 파일)는 객체 파일(`.o` 파일)로 컴파일된 후  
  링커를 통해 실행 가능한 파일로 변환됨.  
- 개별 모듈의 컴파일 속도는 빨랐지만, 전체 프로그램을 컴파일하고 링크하는 과정이 너무 오래 걸렸다.  

프로그래머들은 무어의 법칙에 따라 컴퓨터 성능이 증가하기를 기다려야 했다.  
결국 링크 시간이 초 단위 수준으로 감소하면서,  
공유 라이브러리 시대가 열리고 .jar 파일 같은 패키징 방식이 등장했다.  

이제는 **다수의 .jar 파일 또는 공유 라이브러리를 빠르게 링크하고 실행할 수 있게 되었으며,  
이 과정에서 컴포넌트 플러그인 아키텍처가 탄생**하게 되었다.  

## 📗 결론  
런타임에 플러그인 형태로 결합할 수 있는 **동적 링크 파일**이  
이 책에서 말하는 **소프트웨어 컴포넌트**에 해당한다.  

여기까지 발전하는 데 **50년이 걸렸다.**  
과거에는 **컴포넌트 플러그인 아키텍처를 적용하려면  
엄청난 노력과 기술이 필요**했지만,  
이제는 **기본적으로 쉽게 사용할 수 있는 수준**까지 발전했다.  
