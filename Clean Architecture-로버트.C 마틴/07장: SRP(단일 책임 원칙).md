# 📕 SRP 단일 책임 원칙
단일 책임 원칙(SRP)은 **모든 모듈이 단 하나의 일만 수행해야 한다는 의미가 아니다.**  
역사적으로 SRP는 다음과 같이 정의된다.  

> **"단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다."**  
> **"하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다."**  

여기서 "액터(Actor)"란 **해당 변경을 요청하는 특정 집단 또는 사용자 그룹**을 의미한다.  
"모듈"은 일반적으로 **소스 파일**을 가리키지만,  
일부 개발 환경에서는 **응집된 함수와 데이터 구조의 집합**을 의미할 수도 있다.  

**"응집성(Cohesion)"** 은 SRP의 핵심 개념이다.  
즉, **단일 액터가 책임지는 코드를 함께 묶는 것이 응집성이며, 이는 SRP를 실현하는 힘이다.**  

## 📗 징후 1: 우발적 중복
<img src="../Clean Architecture-로버트.C 마틴/img/7_1.png" alt="설명" width="400" style="display: block; margin: auto;">

위 클래스는 **SRP를 위반**하고 있다.  
이유는 서로 다른 세 명의 액터가 책임지는 기능을 포함하고 있기 때문이다.

- `calculatePay()` 메서드는 회계팀이 관리  
- `reportHours()` 메서드는 인사팀이 관리  
- `save()` 메서드는 데이터베이스 관리자(DBA)가 관리  

이처럼 개발자가 서로 다른 세 가지 기능을 단일 클래스에 배치하면서,  
각기 다른 액터들이 불필요하게 결합되어 버렸다.  

이러한 결합은 CFO(재무 책임자) 팀이 내린 결정이, COO(운영 책임자) 팀이 의존하는 코드에 영향을 미칠 수 있는 문제를 초래한다.  

서로 다른 액터가 의존하는 코드를 가깝게 배치하면 변경 시 예상치 못한 영향을 주기 때문에 유지보수가 어렵다.  
따라서, **"SRP는 서로 다른 액터가 의존하는 코드를 반드시 분리해야 한다고 말한다."**  

## 📗 징후 2: 병합
소스 파일에 다양한 메서드가 포함되어 있을 때,  
이 메서드들이 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 크다.

현대의 개발 도구들은 매우 강력하지만,  
어떤 도구도 병합 충돌을 완벽하게 해결할 수는 없다.  
결국 병합 과정에서는 항상 위험이 따른다.  

병합 문제는서로 다른 목적을 가진 여러 사람이 동일한 소스 파일을 수정하려고 할 때 발생한다.  
이 문제를 해결하는 가장 좋은 방법은 **서로 다른 액터를 위한 코드를 분리하는 것**이다.  

## 📗 해결책
이 문제를 해결하는 방법은 다양하지만,  
모든 방법의 핵심은 메서드를 각기 다른 클래스로 이동시키는 것이다.  

가장 명확한 해결책은 **데이터와 메서드를 분리하는 방식**이다.  

첫 번째 방법은 메서드가 없는 `EmployeeData` 클래스를 생성하고,  
각 클래스가 이를 공유하도록 하는 방식이다.  

- 각 클래스는 자신에게 필요한 메서드만 포함한다.  
- 서로 다른 클래스들이 존재를 모르는 상태로 유지되어야 한다.  
- 이를 통해 "우연한 중복(Accidental Duplication)"을 방지할 수 있다.  

<img src="../Clean Architecture-로버트.C 마틴/img/7_2.png" alt="설명" width="400" style="display: block; margin: auto;">

하지만 이 방법은 개발자가 세 개의 클래스를 직접 생성하고 추적해야 한다는 단점이 있다.  
이를 해결하기 위해 **퍼사드(Facade) 패턴**을 사용할 수 있다.  

<img src="../Clean Architecture-로버트.C 마틴/img/7_3.png" alt="설명" width="400" style="display: block; margin: auto;">

- `EmployeeFacade` 클래스는 실제 로직을 담지 않고,  
  필요한 객체를 생성하고 메서드 호출을 적절한 클래스로 위임하는 역할을 한다.  
- 이를 통해 클라이언트 코드에서 개별 클래스를 직접 관리할 필요가 없어진다. 

두 번째 방법은 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식이다.  

<img src="../Clean Architecture-로버트.C 마틴/img/7_4.png" alt="설명" width="400" style="display: block; margin: auto;">

일각에서는 **각 클래스가 단 하나의 메서드만 가져야 한다는 주장**을 펼치지만,  
이는 현실적이지 않다.  

실제 개발에서는 급여 계산, 보고서 생성, 데이터 저장 등 다양한 메서드가 같은 "기능 그룹" 내에서 유기적으로 작동해야 한다.  

- 하나의 클래스는 관련된 여러 메서드를 포함할 수 있다.  
- 각 클래스는 하나의 유효 범위를 가지며, 외부에서는 내부 구현을 알 필요가 없다.  

결론적으로,  
각 클래스가 **응집력 있는 메서드 그룹을 유지하면서, 책임을 적절히 분리하는 것이 SRP를 준수하는 방법**이다.  

## 📗 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.  

하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다.  
컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍처 수준에서는 아키텍처 겨예의 생성을 책임지는 변경의 축이 된다.