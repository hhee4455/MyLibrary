# 📕 LSP 리스코프 치환 원칙

하위 타입(Subtype)은 다음과 같이 정의할 수 있다.  

> **치환 원칙**이 필요하다.  
> S 타입의 객체 `o1` 각각에 대응하는 T 타입 객체 `o2`가 존재하며,  
> T 타입으로 작성된 프로그램에서 `o2`를 `o1`으로 치환하더라도  
> **프로그램의 행위가 변하지 않는다면, S는 T의 하위 타입이다.**  

이 개념을 명확히 이해하기 위해 몇 가지 예제를 살펴보자.  

## 📗 상속을 사용하도록 가이드하기  
<img src="../Clean Architecture-로버트.C 마틴/img/9_1.png" alt="설명" width="500" style="display: block; margin: auto;">

위 설계는 LSP를 준수한다.  
이는 Billing 애플리케이션이 License의 하위 타입이 무엇인지에 의존하지 않기 때문이다.  

즉, **모든 하위 타입은 License 타입을 치환할 수 있다.**  

## 📗 정사각형/직사각형 문제  
<img src="../Clean Architecture-로버트.C 마틴/img/9_2.png" alt="설명" width="400" style="display: block; margin: auto;">

위 그림은 LSP를 위반하는 대표적인 예제인 정사각형/직사각형 문제이다.  

- `Rectangle`의 높이와 너비는 **서로 독립적으로 변경 가능**하다.  
- 그러나 `Square`의 높이와 너비는 **항상 함께 변경**되어야 한다.  

`User`는 자신이 Rectangle과 대화한다고 생각하지만,  
실제로 Square가 전달되면 예상과 다른 동작이 발생할 수 있다.  

이 문제를 해결하려면 User가 Square인지 검사하는 코드(예: `if` 문)를 추가해야 한다.  
그러나 이렇게 하면 User의 동작이 특정 타입에 의존하게 되어, **LSP를 위반하게 된다.**  
즉, 타입 간 **치환 가능성(Substitutability)이 사라지게 된다.**  

## 📗 LSP와 아키텍처  

과거에는 LSP가 **단순히 상속을 올바르게 사용하는 방법**으로 여겨졌다.  
그러나 시간이 지나면서, **인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙**으로 발전해 왔다.  

아키텍처 관점에서 **LSP를 올바르게 이해하는 방법은, 이 원칙을 위반했을 때 시스템에서 어떤 문제가 발생하는지를 관찰하는 것이다.**  

## 📗 LSP 위배 사례  
택시 파견 서비스 애플리케이션을 예로 들어보자.  
운전기사 데이터는 URI에 저장되어 있으며,  
고객이 운전기사를 요청하면 시스템은 해당 기사의 URI를 이용하여 위치로 파견한다.  

예를 들어, 밥의 택시 파견 URI는 다음과 같다.  

```  
purplecab.com/driver/Bob  
```  

시스템은 여기에 파견 정보를 추가하여 PUT 요청을 보낸다.  

```  
purplecab.com/driver/Bob  
            /pickupAddress/24 Maple St.  
            /pickupTime/153  
            /destination/ORD  
```  

여러 택시 업체가 동일한 REST 인터페이스를 준수해야 하지만,  
ACME라는 택시 회사는 `destination` 필드를 `dest`로 축약하여 사용한다.  
이러한 차이로 인해 기존 택시 업체와 통합 시 문제가 발생하게 된다.  

당연히 이 예외 사항을 처리하는 로직을 추가해야 한다.  
가장 간단한 방법은 if 문을 추가하여 예외 처리하는 것이다.  

```  
if (driver.getDispatchUri().startsWith("acme.com")) {  
    // ACME의 예외 처리  
}  
```  

그러나 숙련된 아키텍트라면 이런 방식의 구성은 절대 용납하지 않는다.  

- `"acme"` 같은 특정 업체명을 코드에 직접 추가하면,  
  **각종 버그, 보안 문제 및 유지보수 어려움이 발생**한다.  
- 만약 ACME가 다른 업체를 인수하면,  
  `"purple"` 같은 또 다른 if 문을 추가해야 하는 상황이 발생할 것이다.  

아키텍트는 **이러한 버그로부터 시스템을 격리해야 한다.**  
따라서, **파견 URI를 키로 사용하는 설정용 데이터베이스를 활용하여  
파견 명령을 생성하는 모듈을 설계하는 방법**을 고려해야 한다.  

또한, 아키텍트는 **REST 서비스 간의 인터페이스가 치환 가능하지 않음을 처리하는  
중요하고 복잡한 매커니즘을 추가해야 한다.**  

즉, **LSP 위반은 단순한 설계 문제가 아니라,  
결과적으로 유지보수성과 확장성을 심각하게 저해하는 원인이 된다.**  


## 📗 결론
LSP는 **아키텍처 수준까지 확장할 수 있으며, 반드시 확장해야 한다.**  

치환 가능성을 조금이라도 위배하면 **시스템 아키텍처가 오염**되며,  
이를 해결하기 위해 **상당량의 별도 메커니즘을 추가해야 할 수도 있다.**  

즉, LSP를 준수하지 않으면 **시스템의 유지보수성과 확장성이 저하되며,  
불필요한 복잡성이 증가하게 된다.**  
