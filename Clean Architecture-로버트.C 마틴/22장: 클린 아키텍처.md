# 📕 클린 아키텍처

많은 소프트웨어 아키텍처는 계층 간의 분리를 통해 **관심사의 분리**를 달성하려고 한다.  
클린 아키텍처는 이러한 분리를 기반으로, **업무 규칙**을 담당하는 계층과 **시스템 인터페이스**를 담당하는 계층을 명확히 나눈다.

클린 아키텍처의 핵심 목표는 시스템이 다음과 같은 특징을 갖도록 설계하는 것이다:

- **프레임워크 독립성**: 아키텍처는 특정 프레임워크에 종속되지 않는다. 프레임워크는 교체 가능한 도구일 뿐이다.
- **테스트 용이성**: 핵심 비즈니스 로직은 UI, 데이터베이스 등 외부 요소와 무관하게 독립적으로 테스트할 수 있다.
- **UI 독립성**: UI를 변경하더라도 시스템의 나머지 구조에 영향을 주지 않는다.
- **데이터베이스 독립성**: 업무 규칙은 특정 데이터베이스 기술에 의존하지 않는다.
- **외부 에이전시에 대한 독립성**: 업무 규칙은 외부 시스템(API, DB, 메시징 시스템 등)에 대해 알 필요가 없으며, 그들과 분리되어 있다.

이러한 원칙을 통합해 하나의 실행 가능한 아키텍처로 만든 것이 아래의 클린 아키텍처 다이어그램이다.

<img src="../Clean Architecture-로버트.C 마틴/img/22_1.png" alt="설명" width="400" style="display: block; margin: auto;">

## 📗 의존성 규칙

클린 아키텍처 다이어그램에서 안으로 들어갈수록 **고수준의 소프트웨어**가 된다.  
바깥 원은 **매커니즘**, 안쪽 원은 **정책**을 의미한다.

이러한 아키텍처가 의도대로 동작하도록 만드는 가장 중요한 규칙이 바로 **의존성 규칙**이다.

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

내부 원에 속한 요소는 외부 원에 속한 함수, 클래스, 변수, 엔티티 등에 **직접 접근하거나 의존해서는 안 된다.**  
외부 계층에서 정의된 데이터 형식조차 **내부 계층에서 사용되어서는 안 된다.**


### 📘 엔티티 (Entities)
- **전사적인 핵심 업무 규칙**을 캡슐화한다.
- 단일 애플리케이션에서는 해당 앱의 **가장 일반적이며 고수준의 규칙**이 엔티티에 해당한다.
- 다른 시스템이나 도메인에서도 재사용될 수 있는 **비즈니스 객체**들이 위치한다.


### 📘 유스케이스 (Use Cases)
- 애플리케이션에 **특화된 업무 규칙**을 포함한다.
- 시스템이 제공해야 할 모든 **유스케이스(기능 시나리오)**를 캡슐화하고 구현한다.
- **엔티티로 들어가고 나가는 데이터 흐름**을 조정한다.
- 유스케이스 계층은 엔티티를 조작하지만, **유스케이스가 변경되더라도 엔티티에 영향을 주지 않아야 한다.**


### 📘 인터페이스 어댑터 (Interface Adapters)
- 유스케이스와 엔티티에 맞는 형식 ↔ 외부 시스템(DB, 웹 등)에 맞는 형식 간 **데이터 변환 역할**을 한다.
- 어댑터는 컨트롤러, 프레젠터, 게이트웨이, 리포지토리 구현체 등을 포함할 수 있다.
- 외부 시스템의 포맷을 **내부에서 사용하기 쉬운 형식**으로 바꿔주며, 반대 방향의 변환도 담당한다.


### 📘 프레임워크와 드라이버 (Frameworks & Drivers)
- **가장 바깥 계층**으로, 웹 프레임워크, 데이터베이스, 메시징 시스템, 외부 API 등 **구현 세부사항**이 위치한다.
- 이 계층은 다른 계층에 **의존해서는 안 되며**, 반대로 안쪽 계층에서 **필요할 경우에만 이들을 사용한다.**
- 교체가 가능해야 하며, 전체 시스템에 영향을 주지 않고 쉽게 바뀔 수 있도록 한다.

### 📘 경계 횡단하기
- 제어 흐름과 의존성의 방향이 **반대**여야 할 때, 일반적으로 **의존성 역전 원칙**을 사용해 해결한다.
- 예를 들어, **유스케이스가 프레젠터를 직접 호출**하는 것은 의존성 규칙을 위반하게 된다.  
  → 따라서 **유스케이스는 내부 원의 인터페이스**를 호출하고, **외부 원의 프레젠터가 그 인터페이스를 구현**하도록 설계한다.
- 아키텍처의 **경계를 횡단**할 때는 항상 이와 같은 방식으로 **의존성 역전**을 적용할 수 있다.


### 📘 경계를 횡단하는 데이터는 어떤 모습인가?
- 경계를 넘어 전달되는 데이터는 **구조체**나 **간단한 데이터 전송 객체(DTO)** 등의 형태일 수 있다.
- 함수 호출 시 **간단한 인자**로 전달하거나, **해시맵 형태**, 또는 **객체로 구성된 구조체** 형태일 수도 있다.
- 중요한 점은, 이 데이터들이 **복잡한 동작이 없는 단순한 구조**여야 하며, **내부 원에서 사용하기에 가장 편리한 형태**여야 한다.
- 즉, **데이터가 전달될 때는 항상 내부의 원(예: 유스케이스, 엔티티)이 필요로 하는 형식으로** 되어 있어야 한다.

## 📗 전형적인 시나리오

<img src="../Clean Architecture-로버트.C 마틴/img/22_2.png" alt="설명" width="500" style="display: block; margin: auto;">

모든 의존성은 경계선을 안쪽으로 가로지르며, 따라서 **의존성 규칙을 준수**한다.
