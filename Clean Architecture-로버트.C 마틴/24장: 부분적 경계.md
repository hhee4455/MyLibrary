# 📕 부분적 경계

아키텍처 경계를 만드는 일에는 많은 비용이 듭니다.  
쌍방향의 다형적 Boundary 인터페이스, Input과 Output을 위한 데이터 구조, 그리고 두 영역을 독립적인 컴포넌트로 격리하기 위한 모든 의존성 관리를 필요로 합니다.

일부 에자일 커뮤니티에서는 이러한 선행 설계를 탐탁지 않게 여깁니다.  
이는 에자일의 핵심 원칙, 즉 변화에 유연하게 대응하는 것을 위배할 수 있기 때문입니다.

## 📗 마지막 단계를 건너뛰기

부분적 경계를 만드는 한 가지 방법은 다음과 같습니다.  
독립적으로 컴파일하고 배포할 수 있도록 컴포넌트를 나누되, 결과적으로는 이들을 하나의 컴포넌트에 모아 함께 컴파일하고 배포하는 것입니다.

결국 완전한 경계를 구축할 때와 같은 코드량과 사전 설계가 필요하지만, 다수의 컴포넌트를 각각 관리할 필요는 없습니다.  
버전 관리나 복잡한 배포 관리도 피할 수 있습니다.

예를 들어 FitNesse의 웹 서버 컴포넌트는 위키나 테스트 영역과 분리되도록 설계되었습니다.  
그러나 사용자가 여러 번 다운로드하는 불편을 피하고자, 모든 것을 하나의 jar 파일로 묶었습니다.  
"다운로드 후 바로 실행"이라는 설계 목표를 달성하기 위함이었습니다.

그러나 이러한 접근은 위험을 동반합니다.  
시간이 지나면서 분리된 웹 컴포넌트는 재사용되지 않았고, 웹과 위키 컴포넌트 간의 경계는 점차 흐려졌습니다.  
결국 의존성이 잘못된 방향으로 흐르게 되었고, 다시 분리하는 작업은 매우 지루하고 어렵게 되었습니다.

## 📗 일차원 경계

완전한 아키텍처 경계는 쌍방향 인터페이스를 통해 양방향 격리를 유지합니다.  
하지만 그보다 간단한 구조로, 추후 완전한 경계로 확장할 수 있도록 설계하는 것도 가능합니다.  
아래는 전통적인 전략 패턴을 활용한 예시입니다.

ServiceBoundary 인터페이스는 클라이언트가 사용하며, 실제 구현은 `ServiceImpl` 클래스가 담당합니다.

<img src="../Clean Architecture-로버트.C 마틴/img/24_1.png" alt="설명" width="500" style="display: block; margin: auto;">

이 구조는 미래의 아키텍처 확장을 위한 기반입니다.  
의존성 역전 원칙이 적용되어 `Client`는 `ServiceImpl`로부터 분리되어 있습니다.  

하지만 점선 화살표에서 보이듯, 이러한 경계는 쉽게 무너질 수 있습니다.  
쌍방향 인터페이스가 없는 상태에서 개발자나 아키텍트가 충분한 훈련과 원칙 의식을 갖추지 못했다면, 비밀 통로가 생겨 경계를 침해할 수 있습니다.

## 📗 퍼사드

가장 단순한 형태의 경계는 **퍼사드(Facade) 패턴**을 활용하는 것입니다. 아래와 같은 구조를 가집니다.

<img src="../Clean Architecture-로버트.C 마틴/img/24_2.png" alt="설명" width="500" style="display: block; margin: auto;">

이 경우, 심지어 의존성 역전 원칙까지도 포기합니다.  
경계는 단일 `Facade` 클래스로 정의되며, 해당 클래스는 모든 서비스 클래스의 메서드를 정의하고 클라이언트 요청을 내부 서비스로 위임합니다.

클라이언트는 서비스 클래스에 직접 접근하지 못합니다.

하지만 이 구조에서는 클라이언트가 서비스 클래스들에 대해 **추이적 종속성**을 갖게 됩니다.  
정적 언어 환경이라면, 서비스 클래스 중 하나의 코드가 변경되었을 때 클라이언트 역시 재컴파일이 필요해집니다.  
또한 이 구조는 비밀 통로를 만들기 쉬워, 경계의 안정성이 크게 떨어질 수 있습니다.
