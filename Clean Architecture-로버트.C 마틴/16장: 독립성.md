# 📕 독립성
좋은 아키텍처는 다음을 지원해야 한다.
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

## 📗 유스케이스
아키텍트의 최우선 관심사는 **유스케이스**이며,  
아키텍처 설계에서도 유스케이스가 **가장 중요한 기준**이 되어야 한다.  
아키텍처는 반드시 **유스케이스를 효과적으로 지원**해야 한다.

다만, 아키텍처는 시스템의 **행위 자체에는 큰 영향을 주지 않는다.**  
좋은 아키텍처는 행위를 **명확히 드러내고 구조적으로 표현**함으로써,  
시스템의 **의도와 목적이 구조 수준에서 드러나도록** 만들어야 한다.

**우수한 아키텍처를 갖춘 시스템**에서는 핵심 유스케이스가 **시스템 구조 자체에서 한눈에 식별**된다.  
이러한 유스케이스는 **일급 요소**로서, 클래스, 함수, 또는 모듈 형태로 아키텍처 내에 존재하며,  
**자신의 역할과 기능을 명확히 설명하는 이름**을 갖는다.

## 📗 운영
운영 관점에서 볼 때, 아키텍처는 **보다 실질적이고 구체적인 역할**을 수행해야 한다.  
운영 지원은 단순한 구조를 넘어 **실제 시스템 행동과 유지에 밀접한 영향을 주는 영역**이다.

## 📗 개발
아키텍처는 **개발 환경을 지원하는 핵심 요소**이기도 하다.  
이와 관련해 **콘웨이의 법칙** 이 적용된다:

> 시스템을 설계하는 조직은,  
> 그 조직의 **의사소통 구조와 동일한 구조**의 시스템을 설계하게 된다.

즉, 아키텍처 설계 시에는  
시스템을 **잘 격리되고 독립적으로 개발 가능한 컴포넌트 단위로 분할**할 수 있어야 하며,  
이를 통해 각 컴포넌트를 **독립적인 팀에 할당**하고  
**효율적인 병렬 개발**이 가능하도록 해야 한다.

## 📗 배포
아키텍처는 **배포의 용이성**을 결정하는 데 중요한 역할을 한다.  
이때 궁극적인 목표는 **즉각적인 배포**이다.

좋은 아키텍처는 다음과 같은 방식으로 배포를 방해하지 않는다:

- 수십 개의 설정 스크립트나 속성 파일을 조금씩 수정하도록 하지 않는다.  
- 꼭 필요한 디렉터리나 파일을 **수작업으로 생성하도록 방치하지 않는다.**  
- 시스템이 **빌드된 즉시 배포 가능**하도록 설계되어야 한다.

이를 위해 시스템은 **컴포넌트 단위로 적절히 분할되고 격리**되어야 한다.  
이때 마스터 컴포넌트 또한 포함되며, 이 컴포넌트는 시스템 전체를 **하나로 통합하고**,  
각 컴포넌트를 **올바르게 구동, 관리, 통합**하는 역할을 해야 한다.

## 📗 선택사항 열어놓기
현실에서 컴포넌트 구조와 관련된 다양한 관심사 사이의 **균형을 잡는 일은 매우 어렵다.**  
대부분의 경우, 모든 **유스케이스, 제약 조건, 팀 구조, 요구사항**을 초기부터 완벽하게 알고 있는 경우는 드물다.

설령 알고 있다고 하더라도, 시스템이 **생명주기의 단계를 거치며**  
이러한 조건들은 **반드시 변화하게 된다.**

그러나 이런 변화 속에서도 **사라지지 않는 것**이 있다.  
바로 **아키텍처 원칙**이다.

이 원칙들은 구현 비용이 크지 않으며,  
**관심사들 간의 균형을 유지하는 데 도움**을 준다.  
또한 시스템을 **적절히 격리된 컴포넌트 단위로 분할**할 수 있게 도와주며,  
이를 통해 **선택사항을 더 많이, 더 오랫동안 열어둘 수 있게** 해준다.

**좋은 아키텍처**는 선택사항을 열어 둠으로써, **변경이 필요할 때 쉽게 변경할 수 있도록 해준다.**

## 📗 계층 결합 분리
아키텍트는 **단일 책임 원칙**과 **공통 폐쇄 원칙**을 적용하여,  
**의도와 맥락에 따라 다르게 변경되는 요소들은 분리**하고,  
**동일한 이유로 변경되는 요소들은 함께 묶어야** 한다.

예를 들어, 하나의 유스케이스가 **UI와 업무 규칙**을 모두 포함한다면,  
두 요소를 **서로 분리**해야 한다.  
이렇게 분리하면 두 요소를 **독립적으로 변경할 수 있을 뿐만 아니라**,  
구조도 **가시적이고 명확하게 유지**할 수 있다.

예시로 보면:
- **입력 필드 유효성 검사**는 **업무 규칙**이다.  
- **계좌의 이자 계산**이나 **재고 품목 집계**도 **업무 규칙**이다.  

이처럼 **서로 다른 유형의 규칙**은 각각 **다른 속도**, **다른 이유**로 변경된다.  
따라서 이들을 **서로 분리하고**,  
**독립적으로 변경 가능**한 구조로 만들어야 한다.

궁극적으로, 아키텍트는 **기술적인 세부사항을 시스템의 핵심 로직으로부터 분리**하여  
**독립적으로 변경할 수 있도록 만드는 것**이 중요하다.

## 📗 유스케이스 결합 분리
시스템은 일반적으로 **수평적인 계층 구조**로 분할되지만,  
동시에 이 계층들을 **수직으로 관통하는 얇은 유스케이스 단위**로도 분리할 수 있다.

이러한 결합 분리를 위해서는,  
예를 들어 **주문 추가 유스케이스의 UI**와  
**주문 삭제 유스케이스의 UI**를 **분리**해야 한다.  

그리고 이러한 분리는 **시스템의 가장 아래 계층까지 수직적으로 적용**되어야 하며,  
각 유스케이스가 **모든 계층에서 서로 겹치지 않도록** 설계해야 한다.

여기에서 **하나의 패턴**을 발견할 수 있다.  
시스템 내에서 **서로 다른 이유로 변경되는 요소들의 결합을 분리**하면,  
**기존 요소에 영향을 주지 않고도 새로운 유스케이스를 계속 추가**할 수 있게 된다.

또한, 유스케이스를 뒷받침하는 **UI와 데이터베이스를 해당 유스케이스 단위로 함께 구성**하면,  
각 유스케이스가 **UI와 DB의 독립된 관점을 사용**하게 된다.

이렇게 하면 새로운 유스케이스를 추가하더라도 **기존 유스케이스에 영향을 줄 가능성은 거의 없다.**

## 📗 결합 분리 모드
유스케이스 간에 **서로 다른 관점이 분리**되어 있다면,  
**높은 처리량이 필요한 유스케이스**와 **낮은 처리량으로 충분한 유스케이스**가  
이미 **자연스럽게 분리되어 있을 가능성**이 높다.

이러한 유스케이스 분리는 **운영 측면에서도 도움이 된다.**  
하지만 그 이점을 제대로 활용하려면,  
**결합을 분리할 때 적절한 '모드'를 선택**해야 한다.

예를 들어, 분리된 컴포넌트를 **서로 다른 서버에서 실행해야 하는 상황**이라면,  
이 컴포넌트들이 **단일 프로세스의 동일한 주소 공간에 상주**해서는 안 된다.  
이들은 반드시 **독립된 서비스**로 구성되어야 하며,  
**네트워크를 통한 통신 방식**을 가져야 한다.

이러한 독립된 컴포넌트를 우리는 **서비스 또는 마이크로서비스**라고 부르며,  
이러한 방식의 아키텍처를 **서비스 지향 아키텍처(SOA)**라고 한다.

즉, **컴포넌트를 서비스 수준까지 분리해야 하는 경우**도 존재한다.

그리고 무엇보다 중요한 것은,  
**좋은 아키텍처는 선택권을 열어 둔다는 것**이다.  
결합 분리 모드는 그런 **선택지 중 하나**일 뿐이다.

## 📗 개발 독립성
기능 팀, 컴포넌트 팀, 계층 팀, 혹은 ㄸ쪼 다른 형태의 팀이라도,  
계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.

## 📗 배포 독립성
유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.  
실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다.

## 📗 중복
소프트웨어에서 **중복은 일반적으로 바람직하지 않다.**  
하지만 **모든 중복이 나쁜 것은 아니다.** 중복에도 여러 종류가 존재한다.

- **진짜 중복**:  
  한 인스턴스가 변경되면,  
  그 인스턴스의 **모든 복사본에도 동일한 변경을 적용해야만** 한다.

- **우발적인 중복**:  
  두 코드 영역이 **각자의 목적과 속도로 독립적으로 발전**한다면,  
  이는 진짜 중복이 아니라 **우연히 비슷해 보이는 코드**일 뿐이다.

유스케이스를 **수직적으로 분리**하다 보면, 이러한 중복 문제를 마주하게 되고,  
**유사한 유스케이스를 통합하고 싶은 유혹**이 생길 수 있다.

그러나 그 순간, **무조건적으로 중복을 제거하는 실수**는 피해야 한다.  
우선 해당 중복이 **진짜 중복인지 아닌지를 먼저 판단해야 한다.**

예를 들어, 계층을 수평으로 분리하는 경우,  
**데이터베이스 레코드의 구조**와 **특정 화면(View)의 데이터 구조**가 매우 비슷해 보일 수 있다.

이때 우리는 흔히,  
별도의 뷰 모델을 만들기보다는 **데이터베이스 레코드를 그대로 UI까지 전달하고 싶다는 유혹**을 받는다.

하지만 이러한 중복은 **거의 확실히 우발적 중복**이다.  
뷰 모델을 별도로 만드는 것은 **큰 부담이 되지 않을 뿐만 아니라**,  
**계층 간 결합을 명확히 분리하고 유지하는 데도 도움이 된다.**

## 📗 결합 분리 모드 (다시)
계층과 유스케이스를 분리하는 방법에는 여러 가지가 있다.

- **소스 수준 분리 모드**  
  소스 코드 모듈 사이의 의존성을 제어할 수 있다.  
  하나의 모듈이 변경되더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 할 수 있다.  
  이 모드에서는 모든 컴포넌트가 같은 주소 공간에서 실행되며, 간단한 함수 호출로 통신한다.

- **배포 수준 분리 모드**  
  jar, DLL, 공유 라이브러리 등 배포 단위 간의 의존성을 제어할 수 있다.  
  한 모듈의 소스 코드가 변경되더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 구성할 수 있다.  
  결합이 분리된 컴포넌트는 독립적으로 배포 가능한 단위로 분할되어 있어야 한다.

- **서비스 수준 분리 모드**  
  의존성을 데이터 구조 수준까지 낮출 수 있으며,  
  오직 네트워크 패킷을 통해서만 통신하도록 만든다.  
  이를 통해 실행 단위들이 소스와 바이너리 변경으로부터 완전히 독립된다.

프로젝트 초기 단계에서는 어떤 분리 모드가 최선일지 판단하기 어렵다.

예를 들어, 처음에는 단일 서버로도 충분할 수 있지만,  
시스템이 성장하면서 별도 서버에서 실행해야 하는 컴포넌트가 생길 가능성이 높다.

이런 경우 초기에는 소스 수준 분리로 시작하고,  
필요해질 때 배포 수준, 나아가 서비스 수준으로 점진적으로 전환하는 것이 바람직하다.

서비스 수준 분리를 무조건 기본 정책으로 삼는 방식은 문제를 일으킬 수 있다.  
비용이 많이 들고, 결합이 너무 큰 단위에서 분리되며,  
마이크로서비스가 작다고 해도 충분히 작은 단위에서 분리되긴 어렵다.

또한 개발 시간뿐만 아니라 시스템 자원 측면에서도 낭비가 발생한다.  
불필요한 서비스 경계를 유지하는 작업은 노력, 메모리, 계산량 모두 낭비로 이어진다.

따라서 컴포넌트를 서비스화할 가능성이 있다면,  
**서비스 수준 직전에서 분리를 멈추고**,  
**컴포넌트를 가능한 한 오랫동안 동일한 주소 공간에 남겨두는 것**이 좋다.  
이를 통해 서비스화에 대한 선택권을 유지할 수 있다.

이 방식에서는  
- 초기에는 소스 수준 분리로 충분하고  
- 배포나 개발에서 문제가 생기면 일부 결합을 배포 수준까지 분리해 대응하며  
- 상황에 따라 점진적으로 서비스 수준으로 확장할 수 있다.

좋은 아키텍처는 시스템이 모노리틱 구조로 시작하더라도  
이후에는 독립적으로 배포 가능한 단위,  
그리고 서비스나 마이크로서비스 수준까지 성장할 수 있게 한다.  
또한 상황이 바뀌었을 때 다시 모노리틱 구조로 되돌릴 수도 있어야 한다.

> 좋은 아키텍처는 이러한 변경으로부터 소스 코드를 보호하고,  
> 결합 분리 모드를 선택사항으로 남겨두어  
> 배포 규모에 따라 가장 적절한 모드를 선택할 수 있게 만들어준다.

## 📗 결론
물론 이 모든 것을 실제로 적용하기는 쉽지 않다.  
그리고 결합 분리 모드를 마치 설정 값 하나 바꾸듯 간단히 전환할 수 있다는 뜻도 아니다.

하지만 시스템의 결합 분리 모드는 **시간이 지나며 바뀔 수밖에 없다.**  
뛰어난 아키텍트는 이러한 **변화를 예측하고**,  
그에 맞춰 시스템이 **큰 무리 없이 적응할 수 있도록 설계**해야 한다.
